Quicksort (in the last section) exemplified how it may be necessary to maintain a *pointer to the last node* in a list. For Quicksort this allowed O(1) constant time joining of sorted lists. But it has costs, including that any sequence of operations on a list must re-establish the pointer to last node before it’s just assumed and used by other code.

Earlier, measuring the time of iterative merge sort on an already sorted list, with a timer with very low (like 0.02 seconds) resolution, exemplified that one may be forced to allocated and deallocate a large number of nodes, in our case about 1 425 408 000 nodes, namely 12 ⋅ 2048 ⋅ 58 000. There is a possibility that if the 2048 ⋅ 58 000 nodes from each of the 11 first runs is instead reused in the next run, the human waiting for the timing results can be considerably reduced. To do that one can just move the nodes to a list of free-to-reuse nodes. Such a list is called a [**free list**](https://en.wikipedia.org/wiki/Free_list) of nodes.

And even earlier I referred, without description, to how one could use the so called **“cursor gap”** technique, also known as a [“gap buffer”](https://en.wikipedia.org/wiki/Gap_buffer), to get the linked list characteristics of O(1) constant time insertion and deletion with an array such as `std::vector`.

The cursor gap technique isn’t directly a linked list technique but it’s very relevant to use of linked lists, because it removes an otherwise possible main reason to use linked lists. Unfortunately the standard library does not provide a cursor gap wrapper, like it provides `std::queue` and `std::stack` wrappers. If it did there would not be any good reason to implement it, or to discuss it here, because unlike linked lists it’s not a popular choice for programming exercises, so you could just use the library.

Likewise, the standard library doesn’t provide a **circular buffer** wrapper, which we’ll use to simplify the implementation of a cursor gap array.
